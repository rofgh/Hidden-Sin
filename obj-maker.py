'''
Current problem:
Currently able to run one sentence for each language setting,
but how to run all the different URs within each language??
Parameter functions turn on or off everything, and then the next step is to step through each possible 
UR within that?
-->>  process_parameters produces all the URs for a language?

Prob #2:
How to create Q, Dec, Imp UR/SRs.  Are these the first settings to apply?  Because 
they allow or disallow some of the fundamental changes?

#3:
When do nodes become null = False?  It must happen before, for example, 
the NullTop and NullSub parameters disallow this, eh?
'''
def produce_UR():
    UR = []
    class Node:
        def __init__(self, name, mother):
            self.name       = name
            # Which node is this node's mother?
            self.mother     = mother
            # Is this node the head of it's level?
            self.head       = False
            # What larger P is this part of? (CP, SP, IP)
            self.phrase     = None
            # Is this node topicalizable?
            self.top        = False
            # Is this node realizable?
            self.real       = False
            # This will be generated by the list of mothers
            self.daughters  = []
            # This will be determined by the headedness and the parameter settings: L or R
            self.pos        = None
            # Is this node null in the current UR?
            self.null       = True
            # Every node is added to this list--don't worry, we'll sort it out later....
            UR.append(self)

    # Set up all doz nodez brah
    CP      = Node(" CP",       None)
    Cbar    = Node(" Cbar",     CP)
    ka      = Node(" ka",       Cbar)
    SP      = Node(" SP",       Cbar)
    wa      = Node("-wa",       Cbar)
    that    = Node(" that",     Cbar)
    Wh      = Node("[+WH]",     Cbar)
    S       = Node(" S",        SP)
    IP      = Node(" IP",       SP)
    Aux     = Node(" Aux",      IP)
    NegP    = Node(" NegP",     IP)
    Not     = Node(" not",      NegP)
    Nev     = Node(" never",    NegP)
    VP      = Node(" VP",       NegP)
    Adv     = Node(" Adv",      VP)
    Vbar3   = Node(" Vbar3",    VP)
    Vbar2   = Node(" Vbar2",    Vbar3)
    PP      = Node(" PP",       Vbar3)
    O2      = Node(" O2",       Vbar2)
    Vbar1   = Node(" Vbar1",    Vbar2)
    V       = Node(" Verb",     Vbar1)
    O1      = Node(" O1",       Vbar1)
    P       = Node(" P",        PP)
    O3      = Node(" O3",       PP)

    # HEAD nodes:
    head_nodes  = [ka, wa, that, Wh, S, Aux, Not, Nev, Adv, P, V, Vbar1, Vbar2]
    for x in head_nodes:
        x.head = True

    # REALIZABLE nodes:
    real_nodes  = [ka, wa, Wh, S, Aux, Not, Nev, Adv, O2, P, O3, V, O1]
    for x in real_nodes:
        x.real  = True

    # TOPICALIZABLE nodes:
    top_nodes   = [that, S, Adv, O2, PP, Vbar1, O1]
    #wa doesn't really belong in here, right, since it is ALWAYS topicalized, if non-null, right...?
    #what does it look like when "That" is topicalized??
    for x in top_nodes:
        x.top   = True

    # Nodes under IP (i.e. they will flip according to parameter 2!):
    IP_nodes    = [Aux, NegP, Not, Nev, VP, Adv, Vbar3, Vbar2, O2, PP, P, O3, Vbar1, V, O1]
    for x in IP_nodes:
        x.phrase = IP

    # Nodes under CP (i.e. they will flip according to Parameter 3!):
    CP_nodes    = [Cbar, ka, SP, wa, that, Wh]
    for x in CP_nodes:
        x.phrase = CP

    # Nodes under SP (i.e. they will flip according to Parameter 1!):
    SP_nodes    = [S, IP]
    for x in SP_nodes:
        x.phrase = SP

    '''
    # All nodes turned on for now, but this should be done elsewhere
    for x in UR:
        x.null = False
    '''
    return UR

def illoc_force_setup(UR, illoc):
    print(UR)
    if illoc == "Q":
        Wh.null = False
    if illoc == "D":
        S.null = False
        V.null = False
    if illoc == "I":
        V.null = False

    return UR
    #initialize the illocutionary force, which (dis)allows certain nodes and movement?
    # Q: Wh becomes realized and non-null
    # DEC: ???
    # IMP: Imperatives are immune to all parametric variation except headedness,
    # but what is allowed or obligatory in IMPs (i.e. maximal projection?)
    # Is there a separate setting for each illoc force in each para?
    pass

def process_parameters(Pa, UR):

########################################### PARAMETERS ###########################################
########################################### HEADEDNESS PARAMETERS ###
    ### PARAMETER 1 ### ONLY AFFECTS HEADEDNESS OF NODES WITHIN SP (i.e. S)
    sps = [x for x in UR if x.phrase == SP]
    # print("\nWHATS IN SP:")
    # [print(x.name) for x in sps]
    if Pa[0] == 0:
        for node in sps:
            if node.head == True:
                node.pos = "L"
            else:
                node.pos = "R"
    if Pa[0] == 1:
        for node in sps:
            if node.head == True:
                node.pos = "R"
            else:
                node.pos = "L"

    ### PARAMETER 2 (Pa[1]) ###  ONLY AFFECTS HEADEDNESS OF NODES WITHIN IP
    ips = [x for x in UR if x.phrase == IP]
    if Pa[1] == 0:
        for node in ips:
            if node.head == True:
                node.pos    = "L"
            else:
                node.pos    = "R" 

    if Pa[1] == 1:
        for node in ips:
            if node.head == True:
                node.pos    = "R"
            else:
                node.pos    = "L"
    # print("\nWHATS IN IP:")
    # [print(x.name,"\t", x.pos) for x in ips]


    ### PARAMETER 3 (Pa[2]) ### ONLY AFFECTS HEADEDNESS OF NODES WITHIN CP
    cps = [x for x in UR if x.phrase == CP]
    # print("\nWHATS IN CP:")
    # [print(x.name) for x in cps]
    if Pa[2] == 0:
        for node in cps:
            if node.head == True:
                node.pos = "L"
            else:
                node.pos = "R"
    if Pa[2] == 1:
        for node in cps:
            if node.head == True:
                node.pos = "R"
            else:
                node.pos = "L"
    '''
########################################### EXISTENTIAL PARAMETERS ###
    ### PARAMETER 4 (Pa[3]) ### OptTop
    if Pa[3] == 0:
        Topic is obligatory (something from top_nodes MUST move to Spec,CP)
        for x in top_nodes:
            attach -wa, set each one as daughter of the CP, then produce an SR
            Could this just be done by adding -wa to the NAME of the topicalized node?
            If there is a Spec,CP, attach -wa to it.
    # The following setting should have more SRs if they all get realized...
    if Pa[3] == 1:
        Topic is optional (Can we just leave it off?)
        Same as above plus no topics?  
    '''
    ### PARAMETER 5 (Pa[4]) ### Null Subject
    
    if Pa[4] == 0:
        pass
    # The following setting should have more SRs if they all (i.e. null and non-null) get realized...
    if Pa[4] == 1:
        S.null = True
    '''

    ### PARAMETER 6 (Pa[5]) ### Null Topic
    #No null topic
    if Pa[5] == 0:
        # topic is always realized, so:
        pass
    if Pa[5] == 1:
        ignore the SRs that would be the same as the above setting, so:
        for x in top_nodes:
            x.null = True

########################################### MOVEMENT PARAMETERS ###
    ### PARAMETER 7 (Pa[6]) ### Wh-Movement
    if Pa[6] == 0:
    if Pa[6] == 1:

    ### PARAMETER 8 (Pa[7]) ### Preposition Stranding
    # PP must move as a group
    if Pa[7] == 0:
        pass
    # O3 can be topicalized without P
    if Pa[7] == 1:
        O3.top = True

    ### PARAMETER 9 (Pa[8]) ### Topic Marking
    if Pa[8] == 0:
        wa.null = True
    if Pa[8] == 1:
        wa.null = False

    ### PARAMETER 10 (Pa[9]) ### VtoI Movement
    if Pa[9] == 0:
    if Pa[9] == 1:

    ### PARAMETER 11 (Pa[10]) ### ItoC Movement
    if Pa[10] == 0:
    if Pa[10] == 1:

    ### PARAMETER 12 (Pa[11]) ### Affix Hopping
    if Pa[11] == 0:
    if Pa[11] == 1:

    ### PARAMETER 13 (Pa[12]) ### Q-Inv
    if Pa[12] == 0:
    if Pa[12] == 1:
    '''
    return UR


### Now that all the parameters are set, apply the changes:
### How to step through all the possible topics, for example?
### [that, S, Adv, O2, PP, Vbar1, O1]
'''
if Pa[3] == True:
    for x in top_nodes:
        Produce an SR for each topicalizable node, all other settings being the same....
'''
    #Does this happen after all movement?
    # generate the daughters

def get_daughters(UR):
    for x in UR:
        if x.mother:
            y = x.mother
            y.daughters.append(x)
        else:
            pass
    return UR
        
def expand(node):
    lis = node.daughters
    if len(lis) != 0:
        for x in lis:
            if x.pos == "L":
                expand(x)
            if x.pos == "R":
                pass
        for x in lis:
            if x.pos == "R":
                expand(x)
            if x.pos == "L":
                pass
    if len(lis) == 0:
        realize(node)

def realize(node):
    if node.null == False:
        if node.real == True:
            print(node.name, end = '')

    '''


    f = expand(CP)
    for x in f:
        if x.pos == "L":
            realize(x)
            expand(x)
        if x.pos == "R":
            realize(x)
            expand(x)
    '''
def UR_permutations(base_UR):
    many_URs = []
    l1 = ["Aux", "Nev", "Adv", "O2", "PP", "O1"]
    total = []
    for r in range(0,len(l1)):
        l_perm = combinations(l1, r)
        for x in l_perm:
            total.append(x)
    for x in total:
        total.index = base_UR

    '''
    print(len(total))
    for x in total:
        if "S" not in x:
            total.remove(x)
            print("deleted"+str(x))
            continue
    '''
    for x in total:
        if "O2" in x:
            if "O1" not in x:
                total.remove(x)
                continue


if __name__ == '__main__':
    ### ALL THE PARAMETER SETTINGS ####
    for x in range(0, 8192):
        language = []
        for digit in format(x, '013b'):
            if digit == '0':
                language.append(0)
            if digit == '1':
                language.append(1)
        print("Language "+str(x+1)+": "+str(language))
        UR = produce_UR()
        illocs = ["Q", "D", "I"]
        UR_list = []
        for x in illocs:

            base_UR = illoc_force_setup(UR, x)
            base_UR = process_parameters(language, base_UR)
            #UR_list = UR_permutations(base_UR)
            for x in UR:
                if x.null == False:
                    print(x.name, end="")
            print()
        '''
        for UR in all_lang_URs:    
            # is each UR an.... object of its own?
            expand(CP)
            print()
            print()
        '''
