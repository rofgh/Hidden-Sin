def nodes(UR):
    node_list = []
    class Node:
        def __init__(self, name, mother):
            self.name       = name
            # Which node is this node's mother?
            self.mother     = mother
            # Is this node the head of it's level/phrase?
            self.head       = False
            # What larger P is this node part of? (CP, SP or IP)
            self.phrase     = None
            # Is this node topicalized?
            self.top        = False
            # Is this node realizable?
            self.real       = False
            # This will be generated by the list of mothers
            self.daughters  = []
            # This will be determined by the headedness and the parameter settings: L or R
            self.pos        = None
            # Is this node nullified?
            self.null       = True
            # Is this node in the current UR?
            self.inUR       = False
            # Every node is added to this list--don't worry, we'll sort it out later....
            node_list.append(self)

    # Set up all doz nodez brah
    CP      = Node("CP",       None)
    Cbar    = Node("Cbar",     CP)
    ka      = Node("ka",       Cbar)
    SP      = Node("SP",       Cbar)
    wa      = Node("[+wa]",    None)
    #that    = Node("that",     Cbar)
    Wh      = Node("[+WH]",    None)
    S       = Node("S",        SP)
    IP      = Node("IP",       SP)
    Aux     = Node("Aux",      IP)
    NegP    = Node("NegP",     IP)
    #Not     = Node("not",      "NegP")
    Nev     = Node("never",    NegP)
    VP      = Node("VP",       NegP)
    Adv     = Node("Adv",      VP)
    Vbar3   = Node("Vbar3",    VP)
    Vbar2   = Node("Vbar2",    Vbar3)
    PP      = Node("PP",       Vbar3)
    O2      = Node("O2",       Vbar2)
    Vbar1   = Node("Vbar1",    Vbar2)
    Verb    = Node("Verb",     Vbar1)
    O1      = Node("O1",       Vbar1)
    P       = Node("P",        PP)
    O3      = Node("O3",       PP)

    # HEAD nodes:
    head_nodes  = [ka, S, Aux, Nev, P, Verb, Vbar1, Vbar2, Vbar3]
    for x in head_nodes:
        x.head = True

    # possibly REALIZABLE nodes:  #OBSOLETE
    #real_nodes  = [ka, wa, Wh, S, Aux, Nev, Verb, O1, O2, P, O3, Adv]
    #for x in real_nodes:
    #    x.real  = True

    # possibly TOPICALIZABLE nodes:
    #top_nodes   = [S, Adv, O1, 02, PP, O3]

    # possibly +WH-able nodes:
    #WH_nodes    = [S, Adv, O1, O2, O3]
    
    # Nodes BG under IP (i.e. they will flip according to Parameter 2!):
    IP_nodes    = [Aux, NegP, Nev, VP, Adv, Vbar3, Vbar2, O2, PP, P, O3, Vbar1, Verb, O1]
    for x in IP_nodes:
        x.phrase = "IP"

    # Nodes BG under CP (i.e. they will flip according to Parameter 3!):
    CP_nodes    = [Cbar, ka, SP]
    for x in CP_nodes:
        x.phrase = "CP"

    # Nodes BG under SP (i.e. they will flip according to Parameter 1!):
    SP_nodes    = [S, IP]
    for x in SP_nodes:
        x.phrase = "SP"

    # Find topicalized object, apply .top = True (See Parameter 8 for PP stranding)
    def tizer(node_list, w):
        topic = None
        for n in node_list:
            if n.name == w:
                #print("This is the node getting topicalized:"+t+" "+n.name)
                n.top   = True
                n.inUR  = True
                n.null  = False
                #print(topic)
                topic   = n
                for cp_search in node_list:
                    if cp_search.name == "CP":
                        #print("change "+n.name+" mother to "+cp_search.name)
                        n.mother    = cp_search
                        n.phrase    = "topic"
                
        assert topic != None, "name incorrect?"+w
        assert topic.name == w, "name incorrect?"+w
        #attach [+wa] to the topic
        #but we won't know until Parameter 9 if it is null or not!
        for n in node_list: 
            if n.name == "[+wa]":
                n.mother = topic
                #print(n.name+" got topicalized")
        return node_list
    
    # Attach +WH
    def whizer(node_list, w):
        for n in node_list:
            if n.name == w:
                n.inUR  = True
                n.null  = False
                wh      = n
        for n in node_list:
            if n.name == "[+WH]":
                #attach [+WH] as daughter of appropriate node
                n.mother    = wh
                n.inUR      = True
                n.null      = False
                #print(n.name+" got wh'd")
        return node_list

    for x in UR:
        w = x
        wh_t_list = [False, False]
        if "+wh" in x:
            wh_t_list[0]   = True
            w = w.strip("+wh")
        if "+t" in x:
            wh_t_list[1]   = True
            w = w.strip("+t")
        if wh_t_list[0] == True:
            #print("+wh: ", end=w+"\t")
            node_list = whizer(node_list, w)
        if wh_t_list[1] == True:
            #print("+t: ", end=w+"\t")
            node_list = tizer(node_list, w)
     
    for n in node_list:
        if n.name in UR:
            if n.name == "PP":
                continue
            n.null = False
            n.inUR = True
        if "PP" in UR:
            if n.mother == PP:
                n.null = False
                n.inUR = True
    
    '''
    #Annoyingly have to turn PP off now, after it allows for turning on of P and O3
    for n in node_list:
        if n.name == "PP":
            n.null = True
    '''
            
    '''
    for n in node_list:
        if n.inUR == True:
            print(n.name)
    '''
    '''
    node_list = [CP,Cbar,ka,SP,wa,Wh,S,IP,Aux,NegP,Nev,
                VP,Adv,Vbar3,Vbar2,PP,O2,Vbar1,Verb,O1,P,O3]
    '''
    return node_list