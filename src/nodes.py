def nodes(UR):
    node_list = []
    class Node:
        def __init__(self, name, mother):
            self.name       = name
            # Which node is this node's mother?
            self.mother     = mother
            # Is this node the head of it's level/phrase?
            self.head       = False
            # What larger P is this node part of? (CP, SP or IP)
            self.phrase     = None
            # Is this node topicalized?
            self.top        = False
            # Is this node realizable?
            self.real       = False
            # This will be generated by the list of mothers
            self.daughters  = []
            # This will be determined by the headedness and the parameter settings: L or R
            self.pos        = None
            # Is this node nullified?
            self.null       = False
            # IS this node in the current UR?
            self.inUR       = False
            # Every node is added to this list--don't worry, we'll sort it out later....
            node_list.append(self)

    # Set up all doz nodez brah
    CP      = Node("CP",       None)
    Cbar    = Node("Cbar",     CP)
    ka      = Node("ka",       Cbar)
    SP      = Node("SP",       Cbar)
    wa      = Node("-wa",       None)
    #that    = Node(" that",     Cbar)
    Wh      = Node("[+WH]",     None)
    S       = Node("S",        SP)
    IP      = Node("IP",       SP)
    Aux     = Node("Aux",      IP)
    NegP    = Node("NegP",     IP)
    Not     = Node("not",      NegP)
    Nev     = Node("never",    NegP)
    VP      = Node("VP",       NegP)
    Adv     = Node("Adv",      VP)
    Vbar3   = Node("Vbar3",    VP)
    Vbar2   = Node("Vbar2",    Vbar3)
    PP      = Node("PP",       Vbar3)
    O2      = Node("O2",       Vbar2)
    Vbar1   = Node("Vbar1",    Vbar2)
    Verb    = Node("Verb",     Vbar1)
    O1      = Node("O1",       Vbar1)
    P       = Node("P",        PP)
    O3      = Node("O3",       PP)

    # HEAD nodes:
    head_nodes  = [ka, S, Aux, Not, Nev, P, Verb, Vbar1, Vbar2]
    for x in head_nodes:
        x.head = True

    # possibly REALIZABLE nodes:
    real_nodes  = [ka, wa, Wh, S, Aux, Not, Nev, Verb, O1, O2, P, O3, Adv]
    for x in real_nodes:
        x.real  = True

    # possibly TOPICALIZABLE nodes:
    #top_nodes   = [S, Adv, O1, 02, PP, O3]

    # possibly +WH-able nodes:
    #WH_nodes    = [S, Adv, O1, O2, O3]
    
    # Nodes BG under IP (i.e. they will flip according to Parameter 2!):
    IP_nodes    = [Aux, NegP, Not, Nev, VP, Adv, Vbar3, Vbar2, O2, PP, P, O3, Vbar1, Verb, O1]
    for x in IP_nodes:
        x.phrase = "IP"

    # Nodes BG under CP (i.e. they will flip according to Parameter 3!):
    CP_nodes    = [Cbar, ka, SP, Wh]
    for x in CP_nodes:
        x.phrase = "CP"

    # Nodes BG under SP (i.e. they will flip according to Parameter 1!):
    SP_nodes    = [S, IP]
    for x in SP_nodes:
        x.phrase = "SP"

    # Find topicalized object, apply .top = True (Parameter 8 deals with stranding)
    for x in UR:
        if "+t" in x:
            t = x.strip("+t")
            for n in node_list:
                if n.name == t:
                    n.top   = True
                    n.inUR  = True
                    #print(n.name+" got topicalized")
     
    for n in node_list:
        if "PP" in UR:
            if n.mother == PP:
                n.inUR = True
        if n.name in UR:
            n.inUR = True
    '''
    for n in node_list:
        if n.inUR == True:
            print(n.name)
    '''
    node_list = [CP,Cbar,ka,SP,wa,Wh,S,IP,Aux,NegP,Not,Nev,
                VP,Adv,Vbar3,Vbar2,PP,O2,Vbar1,Verb,O1,P,O3]
    return node_list